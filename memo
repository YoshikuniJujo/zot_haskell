2011.09.09 Fri.

\f -> ( f one ) zero
=> S [f]( f one ) ( K zero )
=> S ( S I ( K one ) ) ( K zero )
=> ( ( S ( ( S I ) ( K one ) ) ) ( K zero ) )

( ( 101010100 ( ( 101010100 100 ) ( 1010100 one ) ) ) ( 1010100 zero ) )

1 1 101010100 1 1 101010100 100   1 1010100 1         1 1010100 0

\f -> f one
=> S I ( K one )
=> 1 1 101010100 100 1 1010100 1

echo -n 'lambda expression' | runhaskell lambdaToSKI.hs | \
runhaskell skiToZot.hs | runhaskell addEcho.hs arg | runhaskell zot.hs

cat flipPrint.lambda| runhaskell lambdaToSKI.hs| runhaskell skiToZot.hs | \
runhaskell addEcho.hs 10 | runhaskell zot.hs

reverse:
( \x -> x x ( \x -> x ) ) ( \self -> \remainder -> \c ->
interrogate c ( self self ) ( self self ) ( \print -> remainder ( print c ) ) )

reverse 1 0 1 1

self = \s r c -> int c ( s s ) ( s s ) $ \p -> r $ p c

( \x -> x x ( \x -> x ) ) self 1 0 1 1
=> ( \x -> x x I ) self 1 0 1 1
=> self self I 1 0 1 1
=> ( \s r c -> int c ( s s ) ( s s ) $ \p -> r $ p c ) self I 1 0 1 1
=> int 1 ( self self ) ( self self ) $ \p -> p 1 ) 0 1 1
=> self self ( \p -> p 1 ) 0 1 1
=> ( \s r c -> int c ( s s ) ( s s ) $ \p -> r $ p c ) self ( \p -> p 1 ) 0 1 1
=> int 0 ( self self ) ( self self ) $ \p -> ( \p -> p 1 ) $ p 0 ) 1 1
=> self self ( \p -> p 0 1 ) 1 1
=> self self ( \p -> p 1 0 1 ) 1
=> self self ( \p -> p 1 1 0 1 ) output
=> \p -> ( \p -> p 1 1 0 1 ) $ p output
=> \p -> p output 1 1 0 1
